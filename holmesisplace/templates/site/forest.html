{% extends "base.html" %}
{% block sources %}
<link rel="stylesheet" href="/static/css/forest.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
{% endblock %}
{% block content %}
<canvas class="mycanvas" id="mycanvas">
</canvas>
<script type="module">

    import * as THREE from 'https://unpkg.com/three@0.119.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.119.0/examples/jsm/controls/OrbitControls.js';

    var canvas = document.getElementById('mycanvas');
    const SCREEN_WIDTH = canvas.getBoundingClientRect().width;
    const SCREEN_HEIGHT = canvas.getBoundingClientRect().height;

    var r = 450;

    let mouseY = 0,
    windowHalfY = window.innerHeight / 2;

    const stopcamera = false;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xffffff );
    const [camera, renderer] = init();
    const controls = createControls(camera, renderer)
    // camera.up.set(0, 1, 0);
    camera.lookAt(0, 50, 0);
    animate();

    $(document).ready(function() {
        // rough spacing of trees
        const scale = 500
        // number of trees
        var ntrees = 500
        // array of indexes of trees
        const treeidx = Array.apply(null, {length: ntrees}).map(Number.call, Number)
        const growntree = []
        // array of x's
        const randx = Array.apply(null, {length: ntrees}).map(Function.call, Math.random)
        const allx = randx.map(x => x * scale)
        // array of z's
        const randz = Array.apply(null, {length: ntrees}).map(Function.call, Math.random)
        const allz = randz.map(z => z * scale)
        // create trees in a loop
        for (var i=0; i<ntrees; i++){
            // get random x position
            var randomtree = treeidx[Math.floor(Math.random() * treeidx.length)];
            while (growntree.includes(randomtree)){
                randomtree = treeidx[Math.floor(Math.random() * treeidx.length)];
            }
            // store tree index that has been grown
            growntree.push(randomtree)
            // grow a tree!
            createTree(allx[randomtree], 0.0, allz[randomtree])
        }
    });

    function init() {

        const camera = new THREE.PerspectiveCamera( 80, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 3000 );
        camera.position.x = 50;
        // camera.position.y = 50;
        // camera.position.x = 1000;

        const parameters = [[ 0.25, 0xff7700, 1 ], [ 0.5, 0xff9900, 1 ], [ 0.75, 0xffaa00, 0.75 ], [ 1, 0xffaa00, 0.5 ], [ 1.25, 0x000833, 0.8 ],
            [ 3.0, 0xaaaaaa, 0.75 ], [ 3.5, 0xffffff, 0.5 ], [ 4.5, 0xffffff, 0.25 ], [ 5.5, 0xffffff, 0.125 ]];

        // const geometry = createGeometry();

        // for ( let i = 0; i < parameters.length; ++ i ) {
        //
        //     const p = parameters[ i ];
        //
        //     const material = new THREE.LineBasicMaterial( { color: p[ 1 ], opacity: p[ 2 ] } );
        //
        //     const line = new THREE.LineSegments( geometry, material );
        //     line.scale.x = line.scale.y = line.scale.z = p[ 0 ];
        //     line.userData.originalScale = p[ 0 ];
        //     line.rotation.y = Math.random() * Math.PI;
        //     line.updateMatrix();
        //     scene.add( line );
        //
        // }

        // createTree()

        const renderer = new THREE.WebGLRenderer( { antialias: true, canvas: mycanvas } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
        document.body.appendChild( renderer.domElement );

        document.body.style.touchAction = 'none';
        // document.body.addEventListener( 'pointermove', onPointerMove, false );

        //

        window.addEventListener( 'resize', onWindowResize, false );

        return [camera, renderer]
    }

    function createControls( camera, renderer) {

        var controls = new OrbitControls( camera, renderer.domElement );

        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        controls.keys = [ 65, 83, 68 ];
        return controls
    }

    function createTree(x, y, z){
        const material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.8 } );
        var point1 = new THREE.Vector3(x, y, z)
        var point2 = new THREE.Vector3(x, y + 5.0, z)
        var branch = cylinderMesh(point2, point1, material, 0.1, 0.1)
        scene.add(branch)
        drawTree(x, y + 5.0, z, 360, 10, 1.0, 0.1, material)
    }


    async function drawTree(x1, y1, z1, angle, depth, length, diam, material){
      await sleep(20)
      if (depth > 0){
        var plusOrMinus = Math.random() < 0.5 ? -1 : 1;
        angle = angle * plusOrMinus

        // var x2 = x1 + (Math.cos(angle * Math.PI / 180) * ((depth - 1) / depth) * length);
        // var z2 = z1 + (Math.sin(-angle * Math.PI / 180) * ((depth - 1) / depth) * length);

        var x2 = x1 + (Math.cos(Math.random() * angle * Math.PI / 180) * ((depth - 1) / depth) * length);
        var z2 = z1 + (Math.sin(Math.random() * angle * Math.PI / 180) * ((depth - 1) / depth) * length);
        var y2 = y1 + (0.5 * Math.random() * depth * length)
        var point1 = new THREE.Vector3(x1, y1, z1)
        var point2 = new THREE.Vector3(x2, y2, z2)
        var newdiam = diam * (depth - 1) / depth
        var branch = cylinderMesh(point2, point1, material, diam, newdiam)
        scene.add(branch)
        drawTree(x2, y2, z2, -1.0 * angle, depth - 1, length, newdiam, material);
        drawTree(x2, y2, z2, 1.0 * angle, depth - 1, length, newdiam, material);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function cylinderMesh(point1, pointY, material, diam1, diam2) {
        var direction = new THREE.Vector3().subVectors(pointY, point1);
        var orientation = new THREE.Matrix4();
        orientation.lookAt(point1, pointY, new THREE.Object3D().up);
        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
            0, 0, 1, 0,
            0, -1, 0, 0,
            0, 0, 0, 1));
        var edgeGeometry = new THREE.CylinderBufferGeometry(diam1, diam2, direction.length(), 4, 1);
        var edge = new THREE.Mesh(edgeGeometry, material);
        edge.applyMatrix4(orientation);
        // position based on midpoints - there may be a better solution than this
        edge.position.x = (pointY.x + point1.x) / 2;
        edge.position.y = (pointY.y + point1.y) / 2;
        edge.position.z = (pointY.z + point1.z) / 2;
        return edge;
    }

    // function onPointerMove( event ) {
    //
    //     if ( event.isPrimary === false ) return;
    //
    //     mouseY = event.clientY - windowHalfY;
    //
    // }

    //

    function onWindowResize() {

        const aspect = window.innerWidth / window.innerHeight;

        camera.aspect = aspect;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.update();

    }

    function animate() {
        if (camera.position.y < 100 && stopcamera == false){
            camera.position.y += 0.1
            camera.position.x += 5
        } else if (camera.position.y < 50) {
            stopcamera == true;
        }
        camera.position.x = 50;
        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene, camera );
    }

</script>
{% endblock %}
