{% extends "forest-base.html" %}
{% block sources %}
<link rel="stylesheet" href="/static/css/forest.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
{% endblock %}
{% block content %}
<canvas class="mycanvas" id="mycanvas">
</canvas>

<script type='x-shader/x-vertex' id='vertexShader'>
    precision highp float;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    attribute vec3 position;
    attribute vec3 offset;
    attribute vec4 quaternion;

    // function to apply quaternion to instanced geometry
    vec3 applyQuaternionToVector( vec4 q, vec3 v ){
        return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
    }

    void main() {
      vec3 newposition = applyQuaternionToVector(quaternion, position);
      gl_Position = projectionMatrix * modelViewMatrix * vec4( offset + newposition, 1.0 );
    }
</script>

<script type='x-shader/x-fragment' id='fragmentShader'>
    precision highp float;
    void main() {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }
</script>

<script type="module">
    import * as THREE from '/static/three/build/three.module.js';
    import { OrbitControls } from '/static/three/examples/jsm/controls/OrbitControls.js';
    import { BufferGeometryUtils } from '/static/three/examples/jsm/utils/BufferGeometryUtils.js';
    var canvas = document.getElementById('mycanvas');
    const SCREEN_WIDTH = canvas.getBoundingClientRect().width;
    const SCREEN_HEIGHT = canvas.getBoundingClientRect().height;

    var r = 450;

    let mouseY = 0,
    windowHalfY = window.innerHeight / 2;

    const stopcamera = false;
    const scene = new THREE.Scene();
    const theforest = new THREE.Group()
    // const axesHelper = new THREE.AxesHelper( 5 );
    // scene.add( axesHelper );
    scene.background = new THREE.Color( 0xffffff );
    const [camera, renderer] = init();
    const controls = createControls(camera, renderer)
    // camera.up.set(0, 1, 0);
    camera.lookAt(0, 0, 0);
    animate();

    $(document).ready(function() {
        // add forest
        growforest();
    });

    function init() {

        const camera = new THREE.PerspectiveCamera( 80, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 3000 );
        camera.position.x = 700;
        camera.position.y = 0;
        camera.position.z = 700;
        // camera.position.y = 50;
        // camera.position.x = 1000;

        // define renderer
        const renderer = new THREE.WebGLRenderer( { antialias: true, canvas: mycanvas } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
        document.body.appendChild( renderer.domElement );

        document.body.style.touchAction = 'none';
        // document.body.addEventListener( 'pointermove', onPointerMove, false );
        window.addEventListener( 'resize', onWindowResize, false );

        return [camera, renderer]
    }

    function createControls( camera, renderer) {

        // create orbiting controls
        var controls = new OrbitControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.keys = [ 65, 83, 68 ];
        return controls
    }

    async function growforest(){
        // for number of random trees
        const nforests = 1;
        // rough spacing of trees
        // for the sphere this needs to be at least 90
        const scale = 45;
        // number of trees
        var ntrees = 3000;
        // initial tree height
        var height = 6
        // initial tree diameter
        var diameter = 0.5
        // forest depth
        const depth = 7;
        // outer radius of sphere
        var sphere_radius = 500;
        // add sphere
        const geometry = new THREE.SphereGeometry( sphere_radius, 100, 100 );
        const sphere_material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
        const globe = new THREE.Mesh( geometry, sphere_material );
        scene.add( globe );
        // array of indexes of trees
        const treeidx = Array.apply(null, {length: ntrees * nforests}).map(Number.call, Number)
        // holder to make sure we don't grow a tree which already exists!
        const growntree = []
        // array of x's
        const randx = Array.apply(null, {length: ntrees * nforests}).map(Function.call, Math.random)
        const allx = randx.map(x => x * scale * (Math.random() < 0.5 ? -1 : 1))
        // array of z's
        const randz = Array.apply(null, {length: ntrees * nforests}).map(Function.call, Math.random)
        const allz = randz.map(z => z * scale * (Math.random() < 0.5 ? -1 : 1))
        // standard material, just used for mesh generation
        const material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.8} );
        // instanced material!
        var mat = new THREE.RawShaderMaterial({
          uniforms: {},
          vertexShader: document.getElementById( 'vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
          transparent: false
        });
        // loop through groups of random trees
        for (let iforest=0; iforest < nforests; iforest++){
            // grow a tree at the origin!
            var mothertree = await createTree(0.0, 0.0, 0.0, height, diameter, depth, material)
            // create instance buffer geometry
            var forest = new THREE.InstancedBufferGeometry();
            forest.copy(mothertree)
            // set number of instances
            forest.instanceCount = ntrees
            // create buffer attribute arrays
            // these needs to be an offset array
            // these will be applied by the renderer on the GPU
            var offsets = new Float32Array(ntrees * 3)
            // also quaternions stores quaternions per instance
            // these will be applied by the renderer on the GPU
            var quaternions = new Float32Array(ntrees * 4)
            for (var i=0; i<ntrees; i++){
                // get random x position
                var randomtree = treeidx[Math.floor(Math.random() * treeidx.length)];
                // store tree position that has been grown, i.e. the instance
                growntree.push(randomtree)
                // spherical positioning
                var spherepos = new THREE.Spherical( sphere_radius, allx[randomtree], allz[randomtree] )
                var spherecoords = new THREE.Vector3()
                spherecoords.setFromSpherical(spherepos)
                // calculate angle betwen vertical vector and vector from center
                // of sphere to base
                // get unit vector to tree base on sphere
                var unittree = new THREE.Vector3()
                unittree.setFromSpherical(spherepos)
                unittree.normalize()
                // make quaternion defining rotation
                var rot = new THREE.Quaternion();
                rot.setFromUnitVectors(new THREE.Vector3(0, 1, 0), unittree)
                // store in rotation matrix
                quaternions[i * 3] = rot.x
                quaternions[i * 3 + 1] = rot.y
                quaternions[i * 3 + 2] = rot.z
                quaternions[i * 3 + 3] = rot.w
                // generate offset coordinates
                offsets[i * 3] = spherecoords.x
                offsets[i * 3 + 1] = spherecoords.y
                offsets[i * 3 + 2] = spherecoords.z
            }
            // apply offsets to instanced geometry
            forest.setAttribute( 'offset', new THREE.InstancedBufferAttribute( offsets, 3 ) );
            forest.setAttribute( 'quaternion', new THREE.InstancedBufferAttribute( quaternions, 3 ) );
            // create forest mesh
            var forestmesh = await new THREE.Mesh(forest, mat);
            forestmesh.updateMatrix()
            // add to group
            theforest.add(forestmesh);
        };
        // add group to scene
        scene.add(theforest)
    };

    async function createTree(x, y, z, height, diam, depth, material){
        // creates a random tree
        // then instances it to array
        // first create group gridholder
        let mygroup = new THREE.Group()
        var point1 = new THREE.Vector3(x, y, z)
        var point2 = new THREE.Vector3(x, y + height, z)
        var trunk = cylinderMesh(point2, point1, material, diam, diam)
        // var trunk = lineMesh(point2, point1, material, 0.1, 0.1)
        // make sure matrix is up to date
        trunk.updateMatrix()
        // get geometry
        var trunkgeom = trunk.geometry
        // update branch geometry with mesh matrix
        trunkgeom.applyMatrix4(trunk.matrix)
        // create holder for all branches
        var geoms = []
        geoms.push(trunkgeom)
        // create branches
        await drawTree(x, y + height, z, 360, depth, height, diam, material, mygroup)
        // now group everything
        for (var i=0; i < mygroup.children.length; i++){
            // get branch mesh
            var thisbranch = mygroup.children[i]
            // make sure matrix is up to date
            thisbranch.updateMatrix()
            // get geometry
            var geom = thisbranch.geometry
            // apply mesh matrix to geometry to position properly
            geom.applyMatrix4(thisbranch.matrix)
            geoms.push(geom)
        };
        // make a single geometry from all
        var singletree = BufferGeometryUtils.mergeBufferGeometries(geoms, false)
        return singletree
    }


    async function drawTree(x1, y1, z1, angle, depth, length, diam, material, mygroup){
      // await sleep(20)
      if (depth > 0){
        var plusOrMinus = Math.random() < 0.5 ? -1 : 1;
        angle = angle * plusOrMinus
        var x2 = x1 + (Math.cos((Math.random() + Math.random()) * angle * Math.PI / 180) * ((depth - 1) / depth) * length);
        var z2 = z1 + (Math.sin((Math.random() + Math.random()) * angle * Math.PI / 180) * ((depth - 1) / depth) * length);
        var y2 = y1 + (0.5 * Math.random() * depth * length)
        var point1 = new THREE.Vector3(x1, y1, z1)
        var point2 = new THREE.Vector3(x2, y2, z2)
        var newdiam = diam * (depth - 1) / depth
        var branch = cylinderMesh(point2, point1, material, diam, newdiam)
        // var branch = lineMesh(point2, point1, material, diam, newdiam)
        mygroup.add(branch)
        await drawTree(x2, y2, z2, -1.0 * angle, depth - 1, length, newdiam, material, mygroup);
        await drawTree(x2, y2, z2, 1.0 * angle, depth - 1, length, newdiam, material, mygroup);
      }
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function cylinderMesh(point1, pointY, material, diam1, diam2) {
        var direction = new THREE.Vector3().subVectors(pointY, point1);
        var orientation = new THREE.Matrix4();
        orientation.lookAt(point1, pointY, new THREE.Object3D().up);
        orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
            0, 0, 1, 0,
            0, -1, 0, 0,
            0, 0, 0, 1));
        var edgeGeometry = new THREE.CylinderBufferGeometry(diam1, diam2, direction.length(), 3, 1);
        var edge = new THREE.Mesh(edgeGeometry, material);
        edge.applyMatrix4(orientation);
        // position based on midpoints - there may be a better solution than this
        edge.position.x = (pointY.x + point1.x) / 2;
        edge.position.y = (pointY.y + point1.y) / 2;
        edge.position.z = (pointY.z + point1.z) / 2;
        return edge;
    }

    // function onPointerMove( event ) {
    //
    //     if ( event.isPrimary === false ) return;
    //
    //     mouseY = event.clientY - windowHalfY;
    //
    // }

    //

    function onWindowResize() {

        const aspect = window.innerWidth / window.innerHeight;

        camera.aspect = aspect;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        controls.update();

    }

    function animate() {
        theforest.rotation.z += 0.005;
        theforest.rotation.y += 0.002;
        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene, camera );
    }

</script>
{% endblock %}
