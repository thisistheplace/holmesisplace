{% extends "forest-base.html" %}
{% block sources %}
<link rel="stylesheet" href="/static/css/snow.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
{% endblock %}
{% block content %}
<canvas class="mycanvas" id="mycanvas"></canvas>

<script type="module">
    import * as THREE from '/static/three/build/three.module.js';
    import { OrbitControls } from '/static/three/examples/jsm/controls/OrbitControls.js';
    import { BufferGeometryUtils } from '/static/three/examples/jsm/utils/BufferGeometryUtils.js';
    var canvas = document.getElementById('mycanvas');
    const SCREEN_WIDTH = canvas.getBoundingClientRect().width;
    const SCREEN_HEIGHT = canvas.getBoundingClientRect().height;

    var r = 450;

    let mouseY = 0,
    windowHalfY = window.innerHeight / 2;
    // snow parameters
    const materials = [];
    let parameters = [];
    // scene variables
    const stopcamera = false;
    const scene = new THREE.Scene();
    const theforest = new THREE.Group()
    const thesun = new THREE.Group();
    const axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );
    scene.background = new THREE.Color( 0x000000 );
    const [camera, renderer] = init();
    const controls = createControls(camera, renderer)
    // camera.up.set(0, 1, 0);
    camera.lookAt(0, 0, 0);
    animate();

    $(document).ready(function() {
        // add forest
        makesnow();
    });

    function init() {
        // add fog to Scene
        scene.fog = new THREE.Fog( 0x000000, 0.0008, 2500 );
        // define camera
        const camera = new THREE.PerspectiveCamera( 80, SCREEN_WIDTH / SCREEN_HEIGHT, 200, 2000 );
        camera.position.x = 600;
        camera.position.y = 0;
        camera.position.z = 600;
        // camera.position.y = 50;
        // camera.position.x = 1000;
        // define renderer
        const renderer = new THREE.WebGLRenderer( { antialias: true, canvas: mycanvas } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
        document.body.appendChild( renderer.domElement );
        document.body.style.touchAction = 'none';
        // document.body.addEventListener( 'pointermove', onPointerMove, false );
        window.addEventListener( 'resize', onWindowResize, false );
        return [camera, renderer]
    }

    function createControls( camera, renderer) {
        // create orbiting controls
        var controls = new OrbitControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.keys = [ 65, 83, 68 ];
        controls.enableZoom = false;
        return controls
    }

    function makesnow(){
        // holder for randomly generated positions
        const geometry = new THREE.BufferGeometry();
    	const vertices = [];

        // load sprite texture
    	const textureLoader = new THREE.TextureLoader();
    	const sprite1 = textureLoader.load( 'static/img/circle.png' );

        // define radius of torus
        const torusradius = 10000

        // generate random positions
    	for ( let i = 0; i < 100000; i ++ ) {
    		// const x = Math.random() * 2000 - 1000;
    		// const y = Math.random() * 2000 - 1000;
    		// const z = Math.random() * 2000 - 1000;
            const coords = toruspoint(torusradius, 100, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI)
    		vertices.push( ...coords );
    	}

        // add positions to buffer geometry
    	geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );

        // parameters for different sprites
    	parameters = [
    		[[ 1, 1, 1 ], sprite1, 10 ],
            [[ 1, 1, 1 ], sprite1, 1 ],
            [[ 1, 1, 1 ], sprite1, 15 ],
            [[ 1, 1, 1 ], sprite1, 0.1 ],
    	];

        // generate array of snow flakes per sprite
    	for ( let i = 0; i < parameters.length; i ++ ) {
            // get parametric info
    		const color = parameters[ i ][ 0 ];
    		const sprite = parameters[ i ][ 1 ];
    		const size = parameters[ i ][ 2 ];
            // make a material
    		materials[ i ] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: false } );
    		materials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ] );
            // build geometry
    		const particles = new THREE.Points( geometry, materials[ i ] );
            // rotate a bit
    		// particles.rotation.x = Math.random() * 6;
    		// particles.rotation.y = Math.random() * 6;
    		// particles.rotation.z = Math.random() * 6;
            particles.rotation.x = Math.PI;
            // adjust offset of ring
            particles.position.x = torusradius
            // add to scene
    		scene.add( particles );
    	}
    };

    function toruspoint(ringrad, tuberad, ringang, tubeang){
        const x = (ringrad + tuberad * Math.sin(tubeang)) * Math.cos(ringang)
        const y = (ringrad + tuberad * Math.cos(tubeang)) * Math.sin(ringang)
        const z = tuberad * Math.sin(tubeang)
        return [x, y, z]
    }

    function onWindowResize() {
        const aspect = window.innerWidth / window.innerHeight;
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
        controls.update();
    }

    function render() {
        // get time update
        const time = Date.now() * 0.000002;
        // rotate different snow groups
        for ( let i = 0; i < scene.children.length; i ++ ) {
            const object = scene.children[ i ];
            if ( object instanceof THREE.Points ) {
                object.rotation.z = -1.0 * time * ( i < 4 ? i + 1 : - ( i + 1 ) );
            }
        }
        // change the material color
        for ( let i = 0; i < materials.length; i ++ ) {
            const color = parameters[ i ][ 0 ];
            const h = ( 360 * ( color[ 0 ] + time ) % 360 ) / 360;
            materials[ i ].color.setHSL( h, color[ 1 ], color[ 2 ] );
        }
        renderer.render( scene, camera );
    }

    function animate() {
        // animate
        requestAnimationFrame( animate );
        render();
        controls.update();
    }

</script>
{% endblock %}
